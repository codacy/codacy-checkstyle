[ {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "allowedAbbreviationLength",
    "description" : "indicates on the number of consecutive capital letters allowed in targeted identifiers\n             (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "list of abbreviations that must be skipped for checking.\n            Abbreviations should be separated by comma, no spaces are allowed."
  }, {
    "name" : "ignoreFinal",
    "description" : "allow to skip variables with final modifier."
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allows to ignore methods tagged with @Override annotation\n            (that usually mean inherited name)."
  }, {
    "name" : "ignoreStatic",
    "description" : "allow to skip variables with static modifier."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "\n              Controls whether to ignore checking for the\n              abstract modifier on classes that match the\n              name.\n            "
  }, {
    "name" : "ignoreName",
    "description" : "\n              Controls whether to ignore checking the name. Realistically\n              only useful if using the check to identify that match name\n              and do not have the abstract modifier.  name.\n            "
  } ]
}, {
  "patternId" : "AnnotationLocation",
  "title" : "AnnotationLocation",
  "parameters" : [ {
    "name" : "allowSamelineMultipleAnnotations",
    "description" : "To allow annotation(s) to be located on the same line as target element."
  }, {
    "name" : "allowSamelineParameterizedAnnotation",
    "description" : "To allow one and only parameterized annotation to be located on the same line as target element."
  }, {
    "name" : "allowSamelineSingleParameterlessAnnotation",
    "description" : "To allow single parameterless annotation to be located on the same line as target element."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationOnSameLine",
  "title" : "AnnotationOnSameLine",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationUseStyle",
  "title" : "AnnotationUseStyle",
  "parameters" : [ {
    "name" : "closingParens",
    "description" : "\n              Defines the policy for ending parenthesis.\n            "
  }, {
    "name" : "elementStyle",
    "description" : "\n              \n                Defines the annotation element styles.\n              \n            "
  }, {
    "name" : "trailingArrayComma",
    "description" : "\n              Defines the policy for trailing comma in arrays.\n            "
  } ]
}, {
  "patternId" : "AnonInnerLength",
  "title" : "AnonInnerLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma"
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "\n              Controls whether to enforce Java style (true) or C style (false).\n            "
  } ]
}, {
  "patternId" : "AtclauseOrder",
  "title" : "AtclauseOrder",
  "parameters" : [ {
    "name" : "tagOrder",
    "description" : "allows to specify the order by tags."
  }, {
    "name" : "target",
    "description" : "allows to specify targets to check at-clauses."
  } ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable(control) characters."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow non-printable escapes."
  } ]
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals"
}, {
  "patternId" : "AvoidNestedBlocks",
  "title" : "AvoidNestedBlocks",
  "parameters" : [ {
    "name" : "allowInSwitchCase",
    "description" : "Allow nested blocks in case statements"
  } ]
}, {
  "patternId" : "AvoidStarImport",
  "title" : "AvoidStarImport",
  "parameters" : [ {
    "name" : "allowClassImports",
    "description" : "\n              whether to allow starred class imports like\n              import java.util.*;.\n            "
  }, {
    "name" : "allowStaticMemberImports",
    "description" : "\n              whether to allow starred static member imports like\n              import static org.junit.Assert.*;\n            "
  }, {
    "name" : "excludes",
    "description" : "\n              packages where star imports are allowed. Note that this property\n              is not recursive, subpackages of excluded packages are not\n              automatically excluded.\n            "
  } ]
}, {
  "patternId" : "AvoidStaticImport",
  "title" : "AvoidStaticImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "excludes"
  } ]
}, {
  "patternId" : "BooleanExpressionComplexity",
  "title" : "BooleanExpressionComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "\n              the maximum allowed number of boolean operations in one\n              expression.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ClassDataAbstractionCoupling",
  "title" : "ClassDataAbstractionCoupling",
  "parameters" : [ {
    "name" : "excludeClassesRegexps",
    "description" : "User-configured regular expressions to ignore classes"
  }, {
    "name" : "excludedClasses",
    "description" : "User-configured class names to ignore"
  }, {
    "name" : "excludedPackages",
    "description" : "User-configured packages to ignore"
  }, {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  } ]
}, {
  "patternId" : "ClassFanOutComplexity",
  "title" : "ClassFanOutComplexity",
  "parameters" : [ {
    "name" : "excludeClassesRegexps",
    "description" : "User-configured regular expressions to ignore classes"
  }, {
    "name" : "excludedClasses",
    "description" : "User-configured class names to ignore"
  }, {
    "name" : "excludedPackages",
    "description" : "User-configured packages to ignore"
  }, {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals"
}, {
  "patternId" : "CustomImportOrder",
  "title" : "CustomImportOrder",
  "parameters" : [ {
    "name" : "customImportOrderRules",
    "description" : "List of order declaration customizing by user."
  }, {
    "name" : "separateLineBetweenGroups",
    "description" : "Force empty line separator between import groups."
  }, {
    "name" : "sortImportsInGroupAlphabetically",
    "description" : "Force grouping alphabetically, in\n                \n                   ASCII sort order."
  }, {
    "name" : "specialImportsRegExp",
    "description" : "RegExp for SPECIAL_IMPORTS group imports."
  }, {
    "name" : "standardPackageRegExp",
    "description" : "RegExp for STANDARD_JAVA_PACKAGE group imports."
  }, {
    "name" : "thirdPartyPackageRegExp",
    "description" : "RegExp for THIRD_PARTY_PACKAGE group imports."
  } ]
}, {
  "patternId" : "CyclomaticComplexity",
  "title" : "CyclomaticComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "switchBlockAsSingleDecisionPoint",
    "description" : "whether to treat the whole switch block as a single decision point"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "whether to ignore constructors"
  }, {
    "name" : "ignoreModifiers",
    "description" : "whether to ignore modifiers"
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "whether to allow default along with case if they are not last"
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "set of tokens with limited occurrences as descendants"
  }, {
    "name" : "maximumDepth",
    "description" : "the maximum depth for descendant counts"
  }, {
    "name" : "maximumMessage",
    "description" : "error message when the maximum count is exceeded"
  }, {
    "name" : "maximumNumber",
    "description" : "a maximum count for descendants"
  }, {
    "name" : "minimumDepth",
    "description" : "the minimum depth for descendant counts"
  }, {
    "name" : "minimumMessage",
    "description" : "error message when the minimum count is not reached"
  }, {
    "name" : "minimumNumber",
    "description" : "a minimum count for descendants"
  }, {
    "name" : "sumTokenCounts",
    "description" : "\n              whether the number of tokens found should be calculated\n              from the sum of the individual token counts\n            "
  } ]
}, {
  "patternId" : "DesignForExtension",
  "title" : "DesignForExtension",
  "parameters" : [ {
    "name" : "ignoredAnnotations",
    "description" : "\n                        Annotations which allow the check to skip the method from validation.\n                    "
  } ]
}, {
  "patternId" : "EmptyBlock",
  "title" : "EmptyBlock",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on block contents"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyCatchBlock",
  "title" : "EmptyCatchBlock",
  "parameters" : [ {
    "name" : "commentFormat",
    "description" : "The format of the first comment inside empty catch"
  }, {
    "name" : "exceptionVariableName",
    "description" : "The name of variable associated with exception"
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad an empty for iterator"
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members"
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members"
  }, {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement"
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "whether to ignore String.equalsIgnoreCase() invocations"
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode"
}, {
  "patternId" : "ExecutableStatementCount",
  "title" : "ExecutableStatementCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "whether only explicit initializations made to\n                null for objects should be checked"
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "\n              Whether the last case group must be checked.\n            "
  }, {
    "name" : "reliefPattern",
    "description" : "\n              Regular expression to match the relief comment that suppresses\n              the warning about a fall through.\n            "
  } ]
}, {
  "patternId" : "FileLength",
  "title" : "FileLength",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "whether to report on each line containing a tab, or just the first instance"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "FinalClass",
  "title" : "FinalClass"
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "ignore primitive types as parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace"
}, {
  "patternId" : "Header",
  "title" : "Header",
  "parameters" : [ {
    "name" : "charset",
    "description" : "character encoding to use when reading the headerFile"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "header",
    "description" : "\n              the required header specified inline. Individual header lines\n              must be separated by the string \"\\n\" (even on platforms with a\n              different line separator), see examples below.\n            "
  }, {
    "name" : "headerFile",
    "description" : "name of the file containing the required header"
  }, {
    "name" : "ignoreLines",
    "description" : "line numbers to ignore"
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Controls whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Controls whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "pattern for names of variables and parameters to ignore"
  }, {
    "name" : "ignoreSetter",
    "description" : "ignoreSetter"
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "setterCanReturnItsClass"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HideUtilityClassConstructor",
  "title" : "HideUtilityClassConstructor"
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "exception class names to reject"
  } ]
}, {
  "patternId" : "IllegalImport",
  "title" : "IllegalImport",
  "parameters" : [ {
    "name" : "illegalClasses",
    "description" : "Class names to reject, if regexp variable is not set, checks if import equals class name. If regexp variable is set, then list of class name will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "illegalPkgs",
    "description" : "Packages to reject, if regexp variable is not set, checks if import is the part of package. If regexp variable is set, then list of packages will be\n                interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "regexp",
    "description" : "Whether the illegalPkgs and illegalClasses should be interpreted as regular expressions"
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "classes that should not be instantiated"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "ignore checking overridden methods (marked with Override or java.lang.Override\n             annotation)."
  }, {
    "name" : "ignoredMethodNames",
    "description" : "names of methods to ignore"
  }, {
    "name" : "illegalClassNames",
    "description" : "throw class names to reject"
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Message which is used to notify about violations;\n            if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern for illegal class names."
  }, {
    "name" : "ignoredMethodNames",
    "description" : "Methods that should not be checked."
  }, {
    "name" : "illegalClassNames",
    "description" : "Classes that should not be used as types in variable\n            declarations, return values or parameters"
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Abstract classes that may be used as types. "
  }, {
    "name" : "memberModifiers",
    "description" : "Check methods and fields with only corresponding modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Whether to validate abstract class names"
  } ]
}, {
  "patternId" : "ImportControl",
  "title" : "ImportControl",
  "parameters" : [ {
    "name" : "file",
    "description" : "file"
  }, {
    "name" : "path",
    "description" : "\n              Regular expression of file paths to which this check should apply. Files that\n              don't match the pattern will not be checked. The pattern will be matched against\n              the full absolute file path.\n            "
  } ]
}, {
  "patternId" : "ImportOrder",
  "title" : "ImportOrder",
  "parameters" : [ {
    "name" : "caseSensitive",
    "description" : "whether string comparison should be case sensitive or not.\n              Case sensitive sorting is in\n              ASCII sort order\n            "
  }, {
    "name" : "groups",
    "description" : "\n              list of imports groups (every group identified either by a\n              common prefix string, or by a regular expression enclosed\n              in forward slashes (e.g. /regexp/)\n            "
  }, {
    "name" : "option",
    "description" : "policy on the relative order between regular imports and static imports"
  }, {
    "name" : "ordered",
    "description" : "whether imports within group should be sorted\n              (It doesn't affect sorting for static imports.)"
  }, {
    "name" : "separated",
    "description" : "\n              whether imports groups should be separated by, at least, one\n              blank line or comment and aren't separated internally\n            "
  }, {
    "name" : "sortStaticImportsAlphabetically",
    "description" : "whether static imports grouped by top or bottom option\n                are sorted alphabetically or not.\n                Attention: It is applied to all static imports as one group."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "useContainerOrderingForStatic",
    "description" : "whether to use container ordering (Eclipse IDE term) for static imports or not"
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "arrayInitIndent",
    "description" : "how far an array initialisation should be indented when on next line"
  }, {
    "name" : "basicOffset",
    "description" : "how far new indentation level should be indented when on the next line"
  }, {
    "name" : "braceAdjustment",
    "description" : "how far a braces should be indented when on the next line"
  }, {
    "name" : "caseIndent",
    "description" : "how far a case label should be indented when on next line"
  }, {
    "name" : "forceStrictCondition",
    "description" : "force strict indent level in line wrapping case. If value is true, line wrap indent\n                have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "how far continuation line should be indented when line-wrapping is present"
  }, {
    "name" : "throwsIndent",
    "description" : "how far a throws clause should be indented when on next line"
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment"
}, {
  "patternId" : "InnerTypeLast",
  "title" : "InnerTypeLast"
}, {
  "patternId" : "InterfaceIsType",
  "title" : "InterfaceIsType",
  "parameters" : [ {
    "name" : "allowMarkerInterfaces",
    "description" : "\n              Controls whether marker interfaces like Serializable are\n              allowed.\n            "
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "JavaNCSS",
  "title" : "JavaNCSS",
  "parameters" : [ {
    "name" : "classMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              class.\n            "
  }, {
    "name" : "fileMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              file including all top level and nested classes.\n            "
  }, {
    "name" : "methodMaximum",
    "description" : "\n              the maximum allowed number of non commenting lines in a\n              method.\n            "
  } ]
}, {
  "patternId" : "JavadocMethod",
  "title" : "JavadocMethod",
  "parameters" : [ {
    "name" : "allowMissingJavadoc",
    "description" : "whether to ignore errors when a method javadoc is missed."
  }, {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a method has parameters\n            but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowMissingPropertyJavadoc",
    "description" : "allowMissingPropertyJavadoc"
  }, {
    "name" : "allowMissingReturnTag",
    "description" : "whether to ignore errors when a method returns\n            non-void type and does not have a return tag in the javadoc."
  }, {
    "name" : "allowMissingThrowsTags",
    "description" : "whether to ignore errors when a method declares\n            that it throws exceptions but does not have matching throws tags\n            in the javadoc."
  }, {
    "name" : "allowThrowsTagsForSubclasses",
    "description" : "whether to allow documented exceptions that\n            are subclass of one of declared exception."
  }, {
    "name" : "allowUndeclaredRTE",
    "description" : "whether to allow documented exceptions that\n            are not declared if they are a subclass of java.lang.RuntimeException"
  }, {
    "name" : "allowedAnnotations",
    "description" : "List of annotations that could allow missed documentation."
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "ignoreMethodNamesRegex",
    "description" : "ignore method whose names are matching specified regex"
  }, {
    "name" : "logLoadErrors",
    "description" : "logLoadErrors"
  }, {
    "name" : "minLineCount",
    "description" : "Minimal amount of lines in method to allow no documentation."
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "suppressLoadErrors",
    "description" : "suppressLoadErrors"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "validateThrows",
    "description" : "Allows validating throws tags."
  } ]
}, {
  "patternId" : "JavadocPackage",
  "title" : "JavadocPackage",
  "parameters" : [ {
    "name" : "allowLegacy",
    "description" : "\n              If set then allow the use of a\n              package.html file.\n            "
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  } ]
}, {
  "patternId" : "JavadocParagraph",
  "title" : "JavadocParagraph",
  "parameters" : [ {
    "name" : "allowNewlineParagraph",
    "description" : "whether the <p> tag should be placed immediately before the first word"
  } ]
}, {
  "patternId" : "JavadocStyle",
  "title" : "JavadocStyle",
  "parameters" : [ {
    "name" : "checkEmptyJavadoc",
    "description" : "\n              Whether to check if the Javadoc is missing a describing text.\n            "
  }, {
    "name" : "checkFirstSentence",
    "description" : "\n              Whether to check the first sentence for proper end of sentence.\n            "
  }, {
    "name" : "checkHtml",
    "description" : "Whether to check for incomplete HTML tags."
  }, {
    "name" : "endOfSentenceFormat",
    "description" : "\n              Format for matching the end of a sentence.\n            "
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "JavadocTagContinuationIndentation",
  "title" : "JavadocTagContinuationIndentation",
  "parameters" : [ {
    "name" : "offset",
    "description" : "How many spaces to use for new indentation level."
  } ]
}, {
  "patternId" : "JavadocType",
  "title" : "JavadocType",
  "parameters" : [ {
    "name" : "allowMissingParamTags",
    "description" : "whether to ignore errors when a class has type parameters\n                but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowUnknownTags",
    "description" : "whether to ignore errors when a Javadoc tag is not recognised."
  }, {
    "name" : "authorFormat",
    "description" : "pattern for @author tag"
  }, {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "versionFormat",
    "description" : "pattern for @version tag"
  } ]
}, {
  "patternId" : "JavadocVariable",
  "title" : "JavadocVariable",
  "parameters" : [ {
    "name" : "excludeScope",
    "description" : "visibility scope where Javadoc comments are not checked"
  }, {
    "name" : "ignoreNamePattern",
    "description" : "regexp to define variable names to ignore"
  }, {
    "name" : "scope",
    "description" : "visibility scope where Javadoc comments are checked"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LeftCurly",
  "title" : "LeftCurly",
  "parameters" : [ {
    "name" : "ignoreEnums",
    "description" : "If true, Check will ignore enums when left curly brace policy is EOL"
  }, {
    "name" : "option",
    "description" : "policy on placement of a left curly brace ('{')"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LineLength",
  "title" : "LineLength",
  "parameters" : [ {
    "name" : "ignorePattern",
    "description" : "pattern for lines to ignore"
  }, {
    "name" : "max",
    "description" : "maximum allowable line length"
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "allowOneCharVarInForLoop",
    "description" : "\n            Allow one character variable name in  initialization expressions in FOR loop. For example:\n              \nfor (int i = 1; i < 10; i++) {}\n              \n            "
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "constantWaiverParentToken",
    "description" : "Token that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreAnnotation",
    "description" : "ignore magic numbers in annotation declarations."
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "ignore magic numbers in field declarations."
  }, {
    "name" : "ignoreHashCodeMethod",
    "description" : "ignore magic numbers in hashCode methods"
  }, {
    "name" : "ignoreNumbers",
    "description" : "non-magic numbers"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "MethodCount",
  "title" : "MethodCount",
  "parameters" : [ {
    "name" : "maxPackage",
    "description" : "maximum allowable number of package methods"
  }, {
    "name" : "maxPrivate",
    "description" : "maximum allowable number of private methods"
  }, {
    "name" : "maxProtected",
    "description" : "maximum allowable number of protected methods"
  }, {
    "name" : "maxPublic",
    "description" : "maximum allowable number of public methods"
  }, {
    "name" : "maxTotal",
    "description" : "maximum allowable number of methods at all scope levels"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "MethodLength",
  "title" : "MethodLength",
  "parameters" : [ {
    "name" : "countEmpty",
    "description" : "\n              whether to count empty lines and single line comments of the\n              form //\n            "
  }, {
    "name" : "max",
    "description" : "maximum allowable number of lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "allowClassName",
    "description" : "allowClassName"
  }, {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether a line break between the identifier and left parenthesis\n              is allowed\n            "
  }, {
    "name" : "option",
    "description" : "policy on how to pad method parameter"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor"
}, {
  "patternId" : "MissingDeprecated",
  "title" : "MissingDeprecated",
  "parameters" : [ {
    "name" : "skipNoJavadoc",
    "description" : "skipNoJavadoc"
  } ]
}, {
  "patternId" : "MissingOverride",
  "title" : "MissingOverride",
  "parameters" : [ {
    "name" : "javaFiveCompatibility",
    "description" : "javaFiveCompatibility"
  } ]
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault"
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Controls whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "ModifierOrder",
  "title" : "ModifierOrder"
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "\n              The maximum number of occurrences to allow without generating a\n              warning\n            "
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "ignoreOccurrenceContext"
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "\n              Regular expression pattern for ignored strings (with quotation marks)\n            "
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations"
}, {
  "patternId" : "MutableException",
  "title" : "MutableException",
  "parameters" : [ {
    "name" : "extendedClassNameFormat",
    "description" : "pattern for extended class names"
  }, {
    "name" : "format",
    "description" : "pattern for exception class names"
  } ]
}, {
  "patternId" : "NPathComplexity",
  "title" : "NPathComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "the maximum threshold allowed"
  } ]
}, {
  "patternId" : "NeedBraces",
  "title" : "NeedBraces",
  "parameters" : [ {
    "name" : "allowEmptyLoopBody",
    "description" : "allows loops with empty bodies"
  }, {
    "name" : "allowSingleLineStatement",
    "description" : "allows single-line statements without braces"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "allowed nesting depth"
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  }, {
    "name" : "lineSeparator",
    "description" : "type of line separator"
  } ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone"
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer"
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "\n              whether whitespace is allowed if the token is at a linebreak\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NonEmptyAtclauseDescription",
  "title" : "NonEmptyAtclauseDescription",
  "parameters" : [ {
    "name" : "javadocTokens",
    "description" : "javadoc tokens to check"
  } ]
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine"
}, {
  "patternId" : "OneTopLevelClass",
  "title" : "OneTopLevelClass"
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename"
}, {
  "patternId" : "OuterTypeNumber",
  "title" : "OuterTypeNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "maximum allowable number of outer types"
  } ]
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder"
}, {
  "patternId" : "PackageAnnotation",
  "title" : "PackageAnnotation"
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment"
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "ignoreOverridden"
  } ]
}, {
  "patternId" : "ParameterNumber",
  "title" : "ParameterNumber",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Ignore number of parameters for methods with @Override annotation"
  }, {
    "name" : "max",
    "description" : "maximum allowable number of parameters"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RedundantImport",
  "title" : "RedundantImport"
}, {
  "patternId" : "RedundantModifier",
  "title" : "RedundantModifier",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Regexp",
  "title" : "Regexp",
  "parameters" : [ {
    "name" : "duplicateLimit",
    "description" : "duplicateLimit"
  }, {
    "name" : "errorLimit",
    "description" : "Controls the maximum number of errors before the check will abort."
  }, {
    "name" : "format",
    "description" : "pattern"
  }, {
    "name" : "ignoreComments",
    "description" : "Controls whether to ignore matches found within comments."
  }, {
    "name" : "illegalPattern",
    "description" : "Controls whether the pattern is required or illegal."
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n              if empty then the default (hard-coded) message is used."
  } ]
}, {
  "patternId" : "RegexpHeader",
  "title" : "RegexpHeader",
  "parameters" : [ {
    "name" : "charset",
    "description" : "character encoding to use when reading the headerFile"
  }, {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "header",
    "description" : "header"
  }, {
    "name" : "headerFile",
    "description" : "name of the file containing the required header"
  }, {
    "name" : "multiLines",
    "description" : "line numbers to repeat (zero or more times)"
  } ]
}, {
  "patternId" : "RegexpMultiline",
  "title" : "RegexpMultiline",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  } ]
}, {
  "patternId" : "RegexpOnFilename",
  "title" : "RegexpOnFilename",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "File type extension of files to process. If this is specified, then\n            only files that match these types are examined with the other patterns."
  }, {
    "name" : "fileNamePattern",
    "description" : "Regular expression to match the file name against."
  }, {
    "name" : "folderPattern",
    "description" : "Regular expression to match the folder path against."
  }, {
    "name" : "ignoreFileNameExtensions",
    "description" : "Whether to ignore the file extension for the file name match."
  }, {
    "name" : "match",
    "description" : "Whether to look for a match or mis-match on the file name, if the\n            fileNamePattern is supplied, otherwise it is applied on the folderPattern."
  } ]
}, {
  "patternId" : "RegexpSingleline",
  "title" : "RegexpSingleline",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of files to process"
  }, {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  } ]
}, {
  "patternId" : "RegexpSinglelineJava",
  "title" : "RegexpSinglelineJava",
  "parameters" : [ {
    "name" : "format",
    "description" : "illegal pattern"
  }, {
    "name" : "ignoreCase",
    "description" : "Controls whether to ignore case when searching."
  }, {
    "name" : "ignoreComments",
    "description" : "Controls whether to ignore text in comments when searching."
  }, {
    "name" : "maximum",
    "description" : "The maximum number of matches required in each file."
  }, {
    "name" : "message",
    "description" : "message which is used to notify about violations,\n            if empty then default(hard-coded) message is used."
  }, {
    "name" : "minimum",
    "description" : "The minimum number of matches required in each file."
  } ]
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "format",
    "description" : "method names to ignore"
  }, {
    "name" : "max",
    "description" : "maximum allowed number of return statements in non-void methods/lambdas"
  }, {
    "name" : "maxForVoid",
    "description" : "maximum allowed number of return statements in void methods/constructors/lambdas"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RightCurly",
  "title" : "RightCurly",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on placement of a right curly brace ('}')"
  }, {
    "name" : "shouldStartLine",
    "description" : "should we check if '}'\n            starts line."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to wrap lines"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression"
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn"
}, {
  "patternId" : "SingleLineJavadoc",
  "title" : "SingleLineJavadoc",
  "parameters" : [ {
    "name" : "ignoreInlineTags",
    "description" : "whether inline tags must be ignored."
  }, {
    "name" : "ignoredTags",
    "description" : "allows to specify at-clauses which are ignored by the check."
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "If set to true, whitespaces surrounding comments will be ignored."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  } ]
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality"
}, {
  "patternId" : "SummaryJavadoc",
  "title" : "SummaryJavadoc",
  "parameters" : [ {
    "name" : "forbiddenSummaryFragments",
    "description" : "forbidden summary fragments"
  }, {
    "name" : "period",
    "description" : "period symbol at the end of first javadoc sentence"
  } ]
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone"
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize"
}, {
  "patternId" : "SuppressWarnings",
  "title" : "SuppressWarnings",
  "parameters" : [ {
    "name" : "format",
    "description" : "\n               The warnings property is a regex pattern.  Any warning\n               being suppressed matching this pattern will be flagged.\n            "
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SuppressWarningsHolder",
  "title" : "SuppressWarningsHolder",
  "parameters" : [ {
    "name" : "aliasList",
    "description" : "Aliases for check names that can be used in code within SuppressWarnings"
  } ]
}, {
  "patternId" : "ThrowsCount",
  "title" : "ThrowsCount",
  "parameters" : [ {
    "name" : "ignorePrivateMethods",
    "description" : "whether private methods must be ignored"
  }, {
    "name" : "max",
    "description" : "maximum allowed number of throws statements"
  } ]
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Pattern to match comments against"
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "pattern for strings allowed before the comment"
  }, {
    "name" : "legalComment",
    "description" : "pattern for text allowed in trailing comments. (This\n                pattern will not be applied to multiline comments and the text of the\n                comment will be trimmed before matching.)"
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "baseName",
    "description" : "\n              Base name of resource bundles which contain message resources. It helps\n              the check to distinguish config and localization resources."
  }, {
    "name" : "fileExtensions",
    "description" : "fileExtensions"
  }, {
    "name" : "requiredTranslations",
    "description" : "requiredTranslations"
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "\n              Controls whether to apply the check to package-private member.\n            "
  }, {
    "name" : "applyToPrivate",
    "description" : "Controls whether to apply the check to private member."
  }, {
    "name" : "applyToProtected",
    "description" : "Controls whether to apply the check to protected member."
  }, {
    "name" : "applyToPublic",
    "description" : "Controls whether to apply the check to public member."
  }, {
    "name" : "format",
    "description" : "Specifies valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "policy on how to pad parentheses"
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Pattern for qualified names of classes which are allowed\n            to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "file type extension of the files to check."
  } ]
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "UnusedImports",
  "title" : "UnusedImports",
  "parameters" : [ {
    "name" : "processJavadoc",
    "description" : "whether to process Javadoc"
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll"
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "A distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allows to ignore variables with a 'final' modifier."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "pattern for ignoring the distance calculation"
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allows to calculate the distance between declaration of variable and its first usage in the different scopes."
  } ]
}, {
  "patternId" : "VisibilityModifier",
  "title" : "VisibilityModifier",
  "parameters" : [ {
    "name" : "allowPublicFinalFields",
    "description" : "allows public final fields"
  }, {
    "name" : "allowPublicImmutableFields",
    "description" : "allows immutable fields to be declared as public if defined in final class"
  }, {
    "name" : "ignoreAnnotationCanonicalNames",
    "description" : "ignore annotations canonical names"
  }, {
    "name" : "immutableClassCanonicalNames",
    "description" : "immutable classes canonical names"
  }, {
    "name" : "packageAllowed",
    "description" : "whether package visible members are allowed"
  }, {
    "name" : "protectedAllowed",
    "description" : "whether protected members are allowed"
  }, {
    "name" : "publicMemberPattern",
    "description" : "pattern for public members that should be ignored"
  } ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyCatches",
    "description" : "allow empty catch bodies"
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "allow empty constructor bodies"
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "allow empty lambda bodies"
  }, {
    "name" : "allowEmptyLoops",
    "description" : "allow empty loop bodies"
  }, {
    "name" : "allowEmptyMethods",
    "description" : "allow empty method bodies"
  }, {
    "name" : "allowEmptyTypes",
    "description" : "allow empty class, interface and enum bodies"
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "ignore whitespace around colon in for-each loops"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WriteTag",
  "title" : "WriteTag",
  "parameters" : [ {
    "name" : "tag",
    "description" : "Name of tag"
  }, {
    "name" : "tagFormat",
    "description" : "Format of tag"
  }, {
    "name" : "tagSeverity",
    "description" : "Severity level when tag is found and printed"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
} ]