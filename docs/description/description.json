[ {
  "patternId" : "AbbreviationAsWordInName",
  "title" : "AbbreviationAsWordInName",
  "parameters" : [ {
    "name" : "allowedAbbreviationLength",
    "description" : "Indicate the number of consecutive capital letters allowed in targeted identifiers (abbreviations in the classes, interfaces, variables and methods names, ... )."
  }, {
    "name" : "allowedAbbreviations",
    "description" : "Specify abbreviations that must be skipped for checking."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allow to skip variables with final modifier."
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allow to ignore methods tagged with @Override annotation (that usually mean inherited name)."
  }, {
    "name" : "ignoreStatic",
    "description" : "Allow to skip variables with static modifier."
  }, {
    "name" : "ignoreStaticFinal",
    "description" : "Allow to skip variables with both static and final modifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AbstractClassName",
  "title" : "AbstractClassName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specify valid identifiers."
  }, {
    "name" : "ignoreModifier",
    "description" : "Control whether to ignore checking for the abstract modifier on classes that match the name."
  }, {
    "name" : "ignoreName",
    "description" : "Control whether to ignore checking the name. Realistically only useful if using the check to identify that match name and do not have the abstract modifier."
  } ]
}, {
  "patternId" : "AnnotationLocation",
  "title" : "AnnotationLocation",
  "parameters" : [ {
    "name" : "allowSamelineMultipleAnnotations",
    "description" : "Allow annotation(s) to be located on the same line as target element."
  }, {
    "name" : "allowSamelineParameterizedAnnotation",
    "description" : "Allow one and only parameterized annotation to be located on the same line as target element."
  }, {
    "name" : "allowSamelineSingleParameterlessAnnotation",
    "description" : "Allow single parameterless annotation to be located on the same line as target element."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationOnSameLine",
  "title" : "AnnotationOnSameLine",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "AnnotationUseStyle",
  "title" : "AnnotationUseStyle",
  "parameters" : [ {
    "name" : "closingParens",
    "description" : "Define the policy for ending parenthesis."
  }, {
    "name" : "elementStyle",
    "description" : "Define the annotation element styles."
  }, {
    "name" : "trailingArrayComma",
    "description" : "Define the policy for trailing comma in arrays."
  } ]
}, {
  "patternId" : "AnonInnerLength",
  "title" : "AnonInnerLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "Specify the maximum number of lines allowed."
  } ]
}, {
  "patternId" : "ArrayTrailingComma",
  "title" : "ArrayTrailingComma",
  "parameters" : [ {
    "name" : "alwaysDemandTrailingComma",
    "description" : "Control whether to always check for a trailing comma, even when an array is inline."
  } ]
}, {
  "patternId" : "ArrayTypeStyle",
  "title" : "ArrayTypeStyle",
  "parameters" : [ {
    "name" : "javaStyle",
    "description" : "Control whether to enforce Java style (true) or C style (false)."
  } ]
}, {
  "patternId" : "AtclauseOrder",
  "title" : "AtclauseOrder",
  "parameters" : [ {
    "name" : "tagOrder",
    "description" : "Specify the order by tags."
  }, {
    "name" : "target",
    "description" : "Specify block tags targeted."
  }, {
    "name" : "violateExecutionOnNonTightHtml",
    "description" : "Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at Tight-HTML Rules."
  } ]
}, {
  "patternId" : "AvoidDoubleBraceInitialization",
  "title" : "AvoidDoubleBraceInitialization",
  "parameters" : [ ]
}, {
  "patternId" : "AvoidEscapedUnicodeCharacters",
  "title" : "AvoidEscapedUnicodeCharacters",
  "parameters" : [ {
    "name" : "allowByTailComment",
    "description" : "Allow use escapes if trail comment is present."
  }, {
    "name" : "allowEscapesForControlCharacters",
    "description" : "Allow use escapes for non-printable, control characters."
  }, {
    "name" : "allowIfAllCharactersEscaped",
    "description" : "Allow if all characters in literal are escaped."
  }, {
    "name" : "allowNonPrintableEscapes",
    "description" : "Allow use escapes for non-printable, whitespace characters."
  } ]
}, {
  "patternId" : "AvoidInlineConditionals",
  "title" : "AvoidInlineConditionals",
  "parameters" : [ ]
}, {
  "patternId" : "AvoidNestedBlocks",
  "title" : "AvoidNestedBlocks",
  "parameters" : [ {
    "name" : "allowInSwitchCase",
    "description" : "Allow nested blocks if they are the only child of a switch case."
  } ]
}, {
  "patternId" : "AvoidNoArgumentSuperConstructorCall",
  "title" : "AvoidNoArgumentSuperConstructorCall",
  "parameters" : [ ]
}, {
  "patternId" : "AvoidStarImport",
  "title" : "AvoidStarImport",
  "parameters" : [ {
    "name" : "allowClassImports",
    "description" : "Control whether to allow starred class imports like import java.util.*;."
  }, {
    "name" : "allowStaticMemberImports",
    "description" : "Control whether to allow starred static member imports like import static org.junit.Assert.*;."
  }, {
    "name" : "excludes",
    "description" : "Specify packages where starred class imports are allowed and classes where starred static member imports are allowed."
  } ]
}, {
  "patternId" : "AvoidStaticImport",
  "title" : "AvoidStaticImport",
  "parameters" : [ {
    "name" : "excludes",
    "description" : "excludes"
  } ]
}, {
  "patternId" : "BooleanExpressionComplexity",
  "title" : "BooleanExpressionComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "Specify the maximum number of boolean operations allowed in one expression."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "CatchParameterName",
  "title" : "CatchParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  } ]
}, {
  "patternId" : "ClassDataAbstractionCoupling",
  "title" : "ClassDataAbstractionCoupling",
  "parameters" : [ {
    "name" : "excludeClassesRegexps",
    "description" : "Specify user-configured regular expressions to ignore classes."
  }, {
    "name" : "excludedClasses",
    "description" : "Specify user-configured class names to ignore."
  }, {
    "name" : "excludedPackages",
    "description" : "Specify user-configured packages to ignore."
  }, {
    "name" : "max",
    "description" : "Specify the maximum threshold allowed."
  } ]
}, {
  "patternId" : "ClassFanOutComplexity",
  "title" : "ClassFanOutComplexity",
  "parameters" : [ {
    "name" : "excludeClassesRegexps",
    "description" : "Specify user-configured regular expressions to ignore classes."
  }, {
    "name" : "excludedClasses",
    "description" : "Specify user-configured class names to ignore."
  }, {
    "name" : "excludedPackages",
    "description" : "Specify user-configured packages to ignore."
  }, {
    "name" : "max",
    "description" : "Specify the maximum threshold allowed."
  } ]
}, {
  "patternId" : "ClassMemberImpliedModifier",
  "title" : "ClassMemberImpliedModifier",
  "parameters" : [ {
    "name" : "violateImpliedStaticOnNestedEnum",
    "description" : "Control whether to enforce that static is explicitly coded on nested enums in classes and records."
  }, {
    "name" : "violateImpliedStaticOnNestedInterface",
    "description" : "Control whether to enforce that static is explicitly coded on nested interfaces in classes and records."
  }, {
    "name" : "violateImpliedStaticOnNestedRecord",
    "description" : "Control whether to enforce that static is explicitly coded on nested records in classes and records."
  } ]
}, {
  "patternId" : "ClassTypeParameterName",
  "title" : "ClassTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  } ]
}, {
  "patternId" : "CommentsIndentation",
  "title" : "CommentsIndentation",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ConstantName",
  "title" : "ConstantName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "Control if check should apply to package-private members."
  }, {
    "name" : "applyToPrivate",
    "description" : "Control if check should apply to private members."
  }, {
    "name" : "applyToProtected",
    "description" : "Control if check should apply to protected members."
  }, {
    "name" : "applyToPublic",
    "description" : "Control if check should apply to public members."
  }, {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  } ]
}, {
  "patternId" : "ConstructorsDeclarationGrouping",
  "title" : "ConstructorsDeclarationGrouping",
  "parameters" : [ ]
}, {
  "patternId" : "CovariantEquals",
  "title" : "CovariantEquals",
  "parameters" : [ ]
}, {
  "patternId" : "CustomImportOrder",
  "title" : "CustomImportOrder",
  "parameters" : [ {
    "name" : "customImportOrderRules",
    "description" : "Specify ordered list of import groups."
  }, {
    "name" : "separateLineBetweenGroups",
    "description" : "Force empty line separator between import groups."
  }, {
    "name" : "sortImportsInGroupAlphabetically",
    "description" : "Force grouping alphabetically, in ASCII sort order."
  }, {
    "name" : "specialImportsRegExp",
    "description" : "Specify RegExp for SPECIAL_IMPORTS group imports."
  }, {
    "name" : "standardPackageRegExp",
    "description" : "Specify RegExp for STANDARD_JAVA_PACKAGE group imports."
  }, {
    "name" : "thirdPartyPackageRegExp",
    "description" : "Specify RegExp for THIRD_PARTY_PACKAGE group imports."
  } ]
}, {
  "patternId" : "CyclomaticComplexity",
  "title" : "CyclomaticComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "Specify the maximum threshold allowed."
  }, {
    "name" : "switchBlockAsSingleDecisionPoint",
    "description" : "Control whether to treat the whole switch block as a single decision point."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DeclarationOrder",
  "title" : "DeclarationOrder",
  "parameters" : [ {
    "name" : "ignoreConstructors",
    "description" : "Control whether to ignore constructors."
  }, {
    "name" : "ignoreModifiers",
    "description" : "Control whether to ignore modifiers (fields, ...)."
  } ]
}, {
  "patternId" : "DefaultComesLast",
  "title" : "DefaultComesLast",
  "parameters" : [ {
    "name" : "skipIfLastAndSharedWithCase",
    "description" : "Control whether to allow default along with case if they are not last."
  } ]
}, {
  "patternId" : "DescendantToken",
  "title" : "DescendantToken",
  "parameters" : [ {
    "name" : "limitedTokens",
    "description" : "Specify set of tokens with limited occurrences as descendants."
  }, {
    "name" : "maximumDepth",
    "description" : "Specify the maximum depth for descendant counts."
  }, {
    "name" : "maximumMessage",
    "description" : "Define the violation message when the maximum count is exceeded."
  }, {
    "name" : "maximumNumber",
    "description" : "Specify a maximum count for descendants."
  }, {
    "name" : "minimumDepth",
    "description" : "Specify the minimum depth for descendant counts."
  }, {
    "name" : "minimumMessage",
    "description" : "Define the violation message when the minimum count is not reached."
  }, {
    "name" : "minimumNumber",
    "description" : "Specify a minimum count for descendants."
  }, {
    "name" : "sumTokenCounts",
    "description" : "Control whether the number of tokens found should be calculated from the sum of the individual token counts."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "DesignForExtension",
  "title" : "DesignForExtension",
  "parameters" : [ {
    "name" : "ignoredAnnotations",
    "description" : "Specify annotations which allow the check to skip the method from validation."
  }, {
    "name" : "requiredJavadocPhrase",
    "description" : "Specify the comment text pattern which qualifies a method as designed for extension. Supports multi-line regex."
  } ]
}, {
  "patternId" : "EmptyBlock",
  "title" : "EmptyBlock",
  "parameters" : [ {
    "name" : "option",
    "description" : "Specify the policy on block contents."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyCatchBlock",
  "title" : "EmptyCatchBlock",
  "parameters" : [ {
    "name" : "commentFormat",
    "description" : "Specify the RegExp for the first comment inside empty catch block. If check meets comment inside empty catch block matching specified format - empty block is suppressed. If it is multi-line comment - only its first line is analyzed."
  }, {
    "name" : "exceptionVariableName",
    "description" : "Specify the RegExp for the name of the variable associated with exception. If check meets variable name matching specified value - empty block is suppressed."
  } ]
}, {
  "patternId" : "EmptyForInitializerPad",
  "title" : "EmptyForInitializerPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "Specify policy on how to pad an empty for iterator."
  } ]
}, {
  "patternId" : "EmptyForIteratorPad",
  "title" : "EmptyForIteratorPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "Specify policy on how to pad an empty for iterator."
  } ]
}, {
  "patternId" : "EmptyLineSeparator",
  "title" : "EmptyLineSeparator",
  "parameters" : [ {
    "name" : "allowMultipleEmptyLines",
    "description" : "Allow multiple empty lines between class members."
  }, {
    "name" : "allowMultipleEmptyLinesInsideClassMembers",
    "description" : "Allow multiple empty lines inside class members."
  }, {
    "name" : "allowNoEmptyLineBetweenFields",
    "description" : "Allow no empty line between fields."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "EmptyStatement",
  "title" : "EmptyStatement",
  "parameters" : [ ]
}, {
  "patternId" : "EqualsAvoidNull",
  "title" : "EqualsAvoidNull",
  "parameters" : [ {
    "name" : "ignoreEqualsIgnoreCase",
    "description" : "Control whether to ignore String.equalsIgnoreCase(String) invocations."
  } ]
}, {
  "patternId" : "EqualsHashCode",
  "title" : "EqualsHashCode",
  "parameters" : [ ]
}, {
  "patternId" : "ExecutableStatementCount",
  "title" : "ExecutableStatementCount",
  "parameters" : [ {
    "name" : "max",
    "description" : "Specify the maximum threshold allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ExplicitInitialization",
  "title" : "ExplicitInitialization",
  "parameters" : [ {
    "name" : "onlyObjectReferences",
    "description" : "Control whether only explicit initializations made to null for objects should be checked."
  } ]
}, {
  "patternId" : "FallThrough",
  "title" : "FallThrough",
  "parameters" : [ {
    "name" : "checkLastCaseGroup",
    "description" : "Control whether the last case group must be checked."
  }, {
    "name" : "reliefPattern",
    "description" : "Define the RegExp to match the relief comment that suppresses the warning about a fall through."
  } ]
}, {
  "patternId" : "FileLength",
  "title" : "FileLength",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "Specify the file extensions of the files to process."
  }, {
    "name" : "max",
    "description" : "Specify the maximum number of lines allowed."
  } ]
}, {
  "patternId" : "FileTabCharacter",
  "title" : "FileTabCharacter",
  "parameters" : [ {
    "name" : "eachLine",
    "description" : "Control whether to report on each line containing a tab, or just the first instance."
  }, {
    "name" : "fileExtensions",
    "description" : "Specify the file extensions of the files to process."
  } ]
}, {
  "patternId" : "FinalClass",
  "title" : "FinalClass",
  "parameters" : [ ]
}, {
  "patternId" : "FinalLocalVariable",
  "title" : "FinalLocalVariable",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "validateEnhancedForLoopVariable",
    "description" : "Control whether to check enhanced for-loop variable."
  }, {
    "name" : "validateUnnamedVariables",
    "description" : "Control whether to check unnamed variables."
  } ]
}, {
  "patternId" : "FinalParameters",
  "title" : "FinalParameters",
  "parameters" : [ {
    "name" : "ignorePrimitiveTypes",
    "description" : "Ignore primitive types as parameters."
  }, {
    "name" : "ignoreUnnamedParameters",
    "description" : "Ignore unnamed parameters."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "GenericWhitespace",
  "title" : "GenericWhitespace",
  "parameters" : [ ]
}, {
  "patternId" : "Header",
  "title" : "Header",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "Specify the file extensions of the files to process."
  }, {
    "name" : "header",
    "description" : "Specify the required header specified inline. Individual header lines must be separated by the string \"\\n\"(even on platforms with a different line separator)."
  }, {
    "name" : "headerFile",
    "description" : "Specify the name of the file containing the required header."
  }, {
    "name" : "ignoreLines",
    "description" : "Specify the line numbers to ignore."
  } ]
}, {
  "patternId" : "HiddenField",
  "title" : "HiddenField",
  "parameters" : [ {
    "name" : "ignoreAbstractMethods",
    "description" : "Control whether to ignore parameters of abstract methods."
  }, {
    "name" : "ignoreConstructorParameter",
    "description" : "Control whether to ignore constructor parameters."
  }, {
    "name" : "ignoreFormat",
    "description" : "Define the RegExp for names of variables and parameters to ignore."
  }, {
    "name" : "ignoreSetter",
    "description" : "Allow to ignore the parameter of a property setter method."
  }, {
    "name" : "setterCanReturnItsClass",
    "description" : "Allow to expand the definition of a setter method to include methods that return the class' instance."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "HideUtilityClassConstructor",
  "title" : "HideUtilityClassConstructor",
  "parameters" : [ {
    "name" : "ignoreAnnotatedBy",
    "description" : "ignoreAnnotatedBy"
  } ]
}, {
  "patternId" : "IllegalCatch",
  "title" : "IllegalCatch",
  "parameters" : [ {
    "name" : "illegalClassNames",
    "description" : "Specify exception class names to reject."
  } ]
}, {
  "patternId" : "IllegalIdentifierName",
  "title" : "IllegalIdentifierName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalImport",
  "title" : "IllegalImport",
  "parameters" : [ {
    "name" : "illegalClasses",
    "description" : "Specify class names to reject, if regexp property is not set, checks if import equals class name. If regexp property is set, then list of class names will be interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "illegalPkgs",
    "description" : "Specify packages to reject, if regexp property is not set, checks if import is the part of package. If regexp property is set, then list of packages will be interpreted as regular expressions. Note, all properties for match will be used."
  }, {
    "name" : "regexp",
    "description" : "Control whether the illegalPkgs and illegalClasses should be interpreted as regular expressions."
  } ]
}, {
  "patternId" : "IllegalInstantiation",
  "title" : "IllegalInstantiation",
  "parameters" : [ {
    "name" : "classes",
    "description" : "Specify fully qualified class names that should not be instantiated."
  } ]
}, {
  "patternId" : "IllegalThrows",
  "title" : "IllegalThrows",
  "parameters" : [ {
    "name" : "ignoreOverriddenMethods",
    "description" : "Allow to ignore checking overridden methods (marked with Override or java.lang.Override annotation)."
  }, {
    "name" : "ignoredMethodNames",
    "description" : "Specify names of methods to ignore."
  }, {
    "name" : "illegalClassNames",
    "description" : "Specify throw class names to reject."
  } ]
}, {
  "patternId" : "IllegalToken",
  "title" : "IllegalToken",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalTokenText",
  "title" : "IllegalTokenText",
  "parameters" : [ {
    "name" : "format",
    "description" : "Define the RegExp for illegal pattern."
  }, {
    "name" : "ignoreCase",
    "description" : "Control whether to ignore case when matching."
  }, {
    "name" : "message",
    "description" : "Define the message which is used to notify about violations; if empty then the default message is used."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "IllegalType",
  "title" : "IllegalType",
  "parameters" : [ {
    "name" : "ignoredMethodNames",
    "description" : "Specify methods that should not be checked."
  }, {
    "name" : "illegalAbstractClassNameFormat",
    "description" : "Specify RegExp for illegal abstract class names."
  }, {
    "name" : "illegalClassNames",
    "description" : "Specify classes that should not be used as types in variable declarations, return values or parameters."
  }, {
    "name" : "legalAbstractClassNames",
    "description" : "Define abstract classes that may be used as types."
  }, {
    "name" : "memberModifiers",
    "description" : "Control whether to check only methods and fields with any of the specified modifiers. This property does not affect method calls nor method references nor record components."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "validateAbstractClassNames",
    "description" : "Control whether to validate abstract class names."
  } ]
}, {
  "patternId" : "ImportControl",
  "title" : "ImportControl",
  "parameters" : [ {
    "name" : "file",
    "description" : "Specify the location of the file containing the import control configuration. It can be a regular file, URL or resource path. It will try loading the path as a URL first, then as a file, and finally as a resource."
  }, {
    "name" : "path",
    "description" : "Specify the regular expression of file paths to which this check should apply. Files that don't match the pattern will not be checked. The pattern will be matched against the full absolute file path."
  } ]
}, {
  "patternId" : "ImportOrder",
  "title" : "ImportOrder",
  "parameters" : [ {
    "name" : "caseSensitive",
    "description" : "Control whether string comparison should be case-sensitive or not. Case-sensitive sorting is in ASCII sort order. It affects both type imports and static imports."
  }, {
    "name" : "groups",
    "description" : "groups"
  }, {
    "name" : "option",
    "description" : "Specify policy on the relative order between type imports and static imports."
  }, {
    "name" : "ordered",
    "description" : "Control whether type imports within each group should be sorted. It doesn't affect sorting for static imports."
  }, {
    "name" : "separated",
    "description" : "Control whether type import groups should be separated by, at least, one blank line or comment and aren't separated internally. It doesn't affect separations for static imports."
  }, {
    "name" : "separatedStaticGroups",
    "description" : "separatedStaticGroups"
  }, {
    "name" : "sortStaticImportsAlphabetically",
    "description" : "Control whether static imports located at top or bottom are sorted within the group."
  }, {
    "name" : "staticGroups",
    "description" : "staticGroups"
  }, {
    "name" : "useContainerOrderingForStatic",
    "description" : "Control whether to use container ordering (Eclipse IDE term) for static imports or not."
  } ]
}, {
  "patternId" : "Indentation",
  "title" : "Indentation",
  "parameters" : [ {
    "name" : "arrayInitIndent",
    "description" : "Specify how far an array initialization should be indented when on next line."
  }, {
    "name" : "basicOffset",
    "description" : "Specify how far new indentation level should be indented when on the next line."
  }, {
    "name" : "braceAdjustment",
    "description" : "Specify how far a braces should be indented when on the next line."
  }, {
    "name" : "caseIndent",
    "description" : "Specify how far a case label should be indented when on next line."
  }, {
    "name" : "forceStrictCondition",
    "description" : "Force strict indent level in line wrapping case. If value is true, line wrap indent have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like."
  }, {
    "name" : "lineWrappingIndentation",
    "description" : "Specify how far continuation line should be indented when line-wrapping is present."
  }, {
    "name" : "throwsIndent",
    "description" : "Specify how far a throws clause should be indented when on next line."
  } ]
}, {
  "patternId" : "InnerAssignment",
  "title" : "InnerAssignment",
  "parameters" : [ ]
}, {
  "patternId" : "InnerTypeLast",
  "title" : "InnerTypeLast",
  "parameters" : [ ]
}, {
  "patternId" : "InterfaceIsType",
  "title" : "InterfaceIsType",
  "parameters" : [ {
    "name" : "allowMarkerInterfaces",
    "description" : "Control whether marker interfaces like Serializable are allowed."
  } ]
}, {
  "patternId" : "InterfaceMemberImpliedModifier",
  "title" : "InterfaceMemberImpliedModifier",
  "parameters" : [ {
    "name" : "violateImpliedAbstractMethod",
    "description" : "Control whether to enforce that abstract is explicitly coded on interface methods."
  }, {
    "name" : "violateImpliedFinalField",
    "description" : "Control whether to enforce that final is explicitly coded on interface fields."
  }, {
    "name" : "violateImpliedPublicField",
    "description" : "Control whether to enforce that public is explicitly coded on interface fields."
  }, {
    "name" : "violateImpliedPublicMethod",
    "description" : "Control whether to enforce that public is explicitly coded on interface methods."
  }, {
    "name" : "violateImpliedPublicNested",
    "description" : "Control whether to enforce that public is explicitly coded on interface nested types."
  }, {
    "name" : "violateImpliedStaticField",
    "description" : "Control whether to enforce that static is explicitly coded on interface fields."
  }, {
    "name" : "violateImpliedStaticNested",
    "description" : "Control whether to enforce that static is explicitly coded on interface nested types."
  } ]
}, {
  "patternId" : "InterfaceTypeParameterName",
  "title" : "InterfaceTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  } ]
}, {
  "patternId" : "InvalidJavadocPosition",
  "title" : "InvalidJavadocPosition",
  "parameters" : [ ]
}, {
  "patternId" : "JavaNCSS",
  "title" : "JavaNCSS",
  "parameters" : [ {
    "name" : "classMaximum",
    "description" : "Specify the maximum allowed number of non commenting lines in a class."
  }, {
    "name" : "fileMaximum",
    "description" : "Specify the maximum allowed number of non commenting lines in a file including all top level and nested classes."
  }, {
    "name" : "methodMaximum",
    "description" : "Specify the maximum allowed number of non commenting lines in a method."
  }, {
    "name" : "recordMaximum",
    "description" : "Specify the maximum allowed number of non commenting lines in a record."
  } ]
}, {
  "patternId" : "JavadocBlockTagLocation",
  "title" : "JavadocBlockTagLocation",
  "parameters" : [ {
    "name" : "tags",
    "description" : "Specify the javadoc tags to process."
  }, {
    "name" : "violateExecutionOnNonTightHtml",
    "description" : "Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at Tight-HTML Rules."
  } ]
}, {
  "patternId" : "JavadocContentLocation",
  "title" : "JavadocContentLocation",
  "parameters" : [ {
    "name" : "location",
    "description" : "Specify the policy on placement of the Javadoc content."
  } ]
}, {
  "patternId" : "JavadocLeadingAsteriskAlign",
  "title" : "JavadocLeadingAsteriskAlign",
  "parameters" : [ {
    "name" : "violateExecutionOnNonTightHtml",
    "description" : "Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at Tight-HTML Rules."
  } ]
}, {
  "patternId" : "JavadocMethod",
  "title" : "JavadocMethod",
  "parameters" : [ {
    "name" : "accessModifiers",
    "description" : "Specify the access modifiers where Javadoc comments are checked."
  }, {
    "name" : "allowMissingParamTags",
    "description" : "Control whether to ignore violations when a method has parameters but does not have matching param tags in the javadoc."
  }, {
    "name" : "allowMissingReturnTag",
    "description" : "Control whether to ignore violations when a method returns non-void type and does not have a return tag in the javadoc."
  }, {
    "name" : "allowedAnnotations",
    "description" : "Specify annotations that allow missed documentation."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "validateThrows",
    "description" : "Control whether to validate throws tags."
  } ]
}, {
  "patternId" : "JavadocMissingLeadingAsterisk",
  "title" : "JavadocMissingLeadingAsterisk",
  "parameters" : [ {
    "name" : "violateExecutionOnNonTightHtml",
    "description" : "Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at Tight-HTML Rules."
  } ]
}, {
  "patternId" : "JavadocMissingWhitespaceAfterAsterisk",
  "title" : "JavadocMissingWhitespaceAfterAsterisk",
  "parameters" : [ {
    "name" : "violateExecutionOnNonTightHtml",
    "description" : "Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at Tight-HTML Rules."
  } ]
}, {
  "patternId" : "JavadocPackage",
  "title" : "JavadocPackage",
  "parameters" : [ {
    "name" : "allowLegacy",
    "description" : "Allow legacy package.html file to be used."
  }, {
    "name" : "fileExtensions",
    "description" : "Specify the file extensions of the files to process."
  } ]
}, {
  "patternId" : "JavadocParagraph",
  "title" : "JavadocParagraph",
  "parameters" : [ {
    "name" : "allowNewlineParagraph",
    "description" : "Control whether the <p> tag should be placed immediately before the first word."
  }, {
    "name" : "violateExecutionOnNonTightHtml",
    "description" : "Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at Tight-HTML Rules."
  } ]
}, {
  "patternId" : "JavadocStyle",
  "title" : "JavadocStyle",
  "parameters" : [ {
    "name" : "checkEmptyJavadoc",
    "description" : "Control whether to check if the Javadoc is missing a describing text."
  }, {
    "name" : "checkFirstSentence",
    "description" : "Control whether to check the first sentence for proper end of sentence."
  }, {
    "name" : "checkHtml",
    "description" : "Control whether to check for incomplete HTML tags."
  }, {
    "name" : "endOfSentenceFormat",
    "description" : "Specify the format for matching the end of a sentence."
  }, {
    "name" : "excludeScope",
    "description" : "Specify the visibility scope where Javadoc comments are not checked."
  }, {
    "name" : "scope",
    "description" : "Specify the visibility scope where Javadoc comments are checked."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "JavadocTagContinuationIndentation",
  "title" : "JavadocTagContinuationIndentation",
  "parameters" : [ {
    "name" : "offset",
    "description" : "Specify how many spaces to use for new indentation level."
  }, {
    "name" : "violateExecutionOnNonTightHtml",
    "description" : "Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at Tight-HTML Rules."
  } ]
}, {
  "patternId" : "JavadocType",
  "title" : "JavadocType",
  "parameters" : [ {
    "name" : "allowMissingParamTags",
    "description" : "Control whether to ignore violations when a class has type parameters but does not have matching param tags in the Javadoc."
  }, {
    "name" : "allowUnknownTags",
    "description" : "Control whether to ignore violations when a Javadoc tag is not recognised."
  }, {
    "name" : "allowedAnnotations",
    "description" : "Specify annotations that allow skipping validation at all. Only short names are allowed, e.g. Generated."
  }, {
    "name" : "authorFormat",
    "description" : "Specify the pattern for @author tag."
  }, {
    "name" : "excludeScope",
    "description" : "Specify the visibility scope where Javadoc comments are not checked."
  }, {
    "name" : "scope",
    "description" : "Specify the visibility scope where Javadoc comments are checked."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  }, {
    "name" : "versionFormat",
    "description" : "Specify the pattern for @version tag."
  } ]
}, {
  "patternId" : "JavadocVariable",
  "title" : "JavadocVariable",
  "parameters" : [ {
    "name" : "excludeScope",
    "description" : "Specify the visibility scope where Javadoc comments are not checked."
  }, {
    "name" : "ignoreNamePattern",
    "description" : "Specify the regexp to define variable names to ignore."
  }, {
    "name" : "scope",
    "description" : "Specify the visibility scope where Javadoc comments are checked."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LambdaBodyLength",
  "title" : "LambdaBodyLength",
  "parameters" : [ {
    "name" : "max",
    "description" : "Specify the maximum number of lines allowed."
  } ]
}, {
  "patternId" : "LambdaParameterName",
  "title" : "LambdaParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  } ]
}, {
  "patternId" : "LeftCurly",
  "title" : "LeftCurly",
  "parameters" : [ {
    "name" : "ignoreEnums",
    "description" : "Allow to ignore enums when left curly brace policy is EOL."
  }, {
    "name" : "option",
    "description" : "Specify the policy on placement of a left curly brace ('{')."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LineLength",
  "title" : "LineLength",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "Specify the file extensions of the files to process."
  }, {
    "name" : "ignorePattern",
    "description" : "Specify pattern for lines to ignore."
  }, {
    "name" : "max",
    "description" : "Specify the maximum line length allowed."
  } ]
}, {
  "patternId" : "LocalFinalVariableName",
  "title" : "LocalFinalVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "LocalVariableName",
  "title" : "LocalVariableName",
  "parameters" : [ {
    "name" : "allowOneCharVarInForLoop",
    "description" : "Allow one character variable name in initialization expressions in FOR loop if one char variable name is prohibited by format regexp."
  }, {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  } ]
}, {
  "patternId" : "MagicNumber",
  "title" : "MagicNumber",
  "parameters" : [ {
    "name" : "constantWaiverParentToken",
    "description" : "Specify tokens that are allowed in the AST path from the number literal to the enclosing constant definition."
  }, {
    "name" : "ignoreAnnotation",
    "description" : "Ignore magic numbers in annotation declarations."
  }, {
    "name" : "ignoreAnnotationElementDefaults",
    "description" : "Ignore magic numbers in annotation elements defaults."
  }, {
    "name" : "ignoreFieldDeclaration",
    "description" : "Ignore magic numbers in field declarations."
  }, {
    "name" : "ignoreHashCodeMethod",
    "description" : "Ignore magic numbers in hashCode methods."
  }, {
    "name" : "ignoreNumbers",
    "description" : "Specify non-magic numbers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "MatchXpath",
  "title" : "MatchXpath",
  "parameters" : [ {
    "name" : "query",
    "description" : "Specify Xpath query."
  } ]
}, {
  "patternId" : "MemberName",
  "title" : "MemberName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "Control if check should apply to package-private members."
  }, {
    "name" : "applyToPrivate",
    "description" : "Control if check should apply to private members."
  }, {
    "name" : "applyToProtected",
    "description" : "Control if check should apply to protected members."
  }, {
    "name" : "applyToPublic",
    "description" : "Control if check should apply to public members."
  }, {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  } ]
}, {
  "patternId" : "MethodCount",
  "title" : "MethodCount",
  "parameters" : [ {
    "name" : "maxPackage",
    "description" : "Specify the maximum number of package methods allowed."
  }, {
    "name" : "maxPrivate",
    "description" : "Specify the maximum number of private methods allowed."
  }, {
    "name" : "maxProtected",
    "description" : "Specify the maximum number of protected methods allowed."
  }, {
    "name" : "maxPublic",
    "description" : "Specify the maximum number of public methods allowed."
  }, {
    "name" : "maxTotal",
    "description" : "Specify the maximum number of methods allowed at all scope levels."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "MethodLength",
  "title" : "MethodLength",
  "parameters" : [ {
    "name" : "countEmpty",
    "description" : "Control whether to count empty lines and comments."
  }, {
    "name" : "max",
    "description" : "Specify the maximum number of lines allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "MethodName",
  "title" : "MethodName",
  "parameters" : [ {
    "name" : "allowClassName",
    "description" : "Control whether to allow a method name to have the same name as the enclosing class name. Setting this property false helps to avoid confusion between constructors and methods."
  }, {
    "name" : "applyToPackage",
    "description" : "Control if check should apply to package-private members."
  }, {
    "name" : "applyToPrivate",
    "description" : "Control if check should apply to private members."
  }, {
    "name" : "applyToProtected",
    "description" : "Control if check should apply to protected members."
  }, {
    "name" : "applyToPublic",
    "description" : "Control if check should apply to public members."
  }, {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  } ]
}, {
  "patternId" : "MethodParamPad",
  "title" : "MethodParamPad",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "Allow a line break between the identifier and left parenthesis."
  }, {
    "name" : "option",
    "description" : "Specify policy on how to pad method parameter."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "MethodTypeParameterName",
  "title" : "MethodTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  } ]
}, {
  "patternId" : "MissingCtor",
  "title" : "MissingCtor",
  "parameters" : [ ]
}, {
  "patternId" : "MissingDeprecated",
  "title" : "MissingDeprecated",
  "parameters" : [ {
    "name" : "violateExecutionOnNonTightHtml",
    "description" : "Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at Tight-HTML Rules."
  } ]
}, {
  "patternId" : "MissingJavadocMethod",
  "title" : "MissingJavadocMethod",
  "parameters" : [ {
    "name" : "allowMissingPropertyJavadoc",
    "description" : "Control whether to allow missing Javadoc on accessor methods for properties (setters and getters)."
  }, {
    "name" : "allowedAnnotations",
    "description" : "Configure annotations that allow missed documentation."
  }, {
    "name" : "excludeScope",
    "description" : "Specify the visibility scope where Javadoc comments are not checked."
  }, {
    "name" : "ignoreMethodNamesRegex",
    "description" : "Ignore method whose names are matching specified regex."
  }, {
    "name" : "minLineCount",
    "description" : "Control the minimal amount of lines in method to allow no documentation."
  }, {
    "name" : "scope",
    "description" : "Specify the visibility scope where Javadoc comments are checked."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "MissingJavadocPackage",
  "title" : "MissingJavadocPackage",
  "parameters" : [ ]
}, {
  "patternId" : "MissingJavadocType",
  "title" : "MissingJavadocType",
  "parameters" : [ {
    "name" : "excludeScope",
    "description" : "Specify the visibility scope where Javadoc comments are not checked."
  }, {
    "name" : "scope",
    "description" : "Specify the visibility scope where Javadoc comments are checked."
  }, {
    "name" : "skipAnnotations",
    "description" : "Specify annotations that allow missed documentation. If annotation is present in target sources in multiple forms of qualified name, all forms should be listed in this property."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "MissingNullCaseInSwitch",
  "title" : "MissingNullCaseInSwitch",
  "parameters" : [ ]
}, {
  "patternId" : "MissingOverride",
  "title" : "MissingOverride",
  "parameters" : [ {
    "name" : "javaFiveCompatibility",
    "description" : "Enable java 5 compatibility mode."
  } ]
}, {
  "patternId" : "MissingSwitchDefault",
  "title" : "MissingSwitchDefault",
  "parameters" : [ ]
}, {
  "patternId" : "ModifiedControlVariable",
  "title" : "ModifiedControlVariable",
  "parameters" : [ {
    "name" : "skipEnhancedForLoopVariable",
    "description" : "Control whether to check enhanced for-loop variable."
  } ]
}, {
  "patternId" : "ModifierOrder",
  "title" : "ModifierOrder",
  "parameters" : [ ]
}, {
  "patternId" : "MultipleStringLiterals",
  "title" : "MultipleStringLiterals",
  "parameters" : [ {
    "name" : "allowedDuplicates",
    "description" : "Specify the maximum number of occurrences to allow without generating a warning."
  }, {
    "name" : "ignoreOccurrenceContext",
    "description" : "Specify token type names where duplicate strings are ignored even if they don't match ignoredStringsRegexp. This allows you to exclude syntactical contexts like annotations or static initializers from the check."
  }, {
    "name" : "ignoreStringsRegexp",
    "description" : "Specify RegExp for ignored strings (with quotation marks)."
  } ]
}, {
  "patternId" : "MultipleVariableDeclarations",
  "title" : "MultipleVariableDeclarations",
  "parameters" : [ ]
}, {
  "patternId" : "MutableException",
  "title" : "MutableException",
  "parameters" : [ {
    "name" : "extendedClassNameFormat",
    "description" : "Specify pattern for extended class names."
  }, {
    "name" : "format",
    "description" : "Specify pattern for exception class names."
  } ]
}, {
  "patternId" : "NPathComplexity",
  "title" : "NPathComplexity",
  "parameters" : [ {
    "name" : "max",
    "description" : "Specify the maximum threshold allowed."
  } ]
}, {
  "patternId" : "NeedBraces",
  "title" : "NeedBraces",
  "parameters" : [ {
    "name" : "allowEmptyLoopBody",
    "description" : "Allow loops with empty bodies."
  }, {
    "name" : "allowSingleLineStatement",
    "description" : "Allow single-line statements without braces."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NestedForDepth",
  "title" : "NestedForDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "Specify maximum allowed nesting depth."
  } ]
}, {
  "patternId" : "NestedIfDepth",
  "title" : "NestedIfDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "Specify maximum allowed nesting depth."
  } ]
}, {
  "patternId" : "NestedTryDepth",
  "title" : "NestedTryDepth",
  "parameters" : [ {
    "name" : "max",
    "description" : "Specify maximum allowed nesting depth."
  } ]
}, {
  "patternId" : "NewlineAtEndOfFile",
  "title" : "NewlineAtEndOfFile",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "Specify the file extensions of the files to process."
  }, {
    "name" : "lineSeparator",
    "description" : "Specify the type of line separator."
  } ]
}, {
  "patternId" : "NoArrayTrailingComma",
  "title" : "NoArrayTrailingComma",
  "parameters" : [ ]
}, {
  "patternId" : "NoClone",
  "title" : "NoClone",
  "parameters" : [ ]
}, {
  "patternId" : "NoCodeInFile",
  "title" : "NoCodeInFile",
  "parameters" : [ ]
}, {
  "patternId" : "NoEnumTrailingComma",
  "title" : "NoEnumTrailingComma",
  "parameters" : [ ]
}, {
  "patternId" : "NoFinalizer",
  "title" : "NoFinalizer",
  "parameters" : [ ]
}, {
  "patternId" : "NoLineWrap",
  "title" : "NoLineWrap",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceAfter",
  "title" : "NoWhitespaceAfter",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "Control whether whitespace is allowed if the token is at a linebreak."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBefore",
  "title" : "NoWhitespaceBefore",
  "parameters" : [ {
    "name" : "allowLineBreaks",
    "description" : "Control whether whitespace is allowed if the token is at a linebreak."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "NoWhitespaceBeforeCaseDefaultColon",
  "title" : "NoWhitespaceBeforeCaseDefaultColon",
  "parameters" : [ ]
}, {
  "patternId" : "NonEmptyAtclauseDescription",
  "title" : "NonEmptyAtclauseDescription",
  "parameters" : [ {
    "name" : "javadocTokens",
    "description" : "javadoc tokens to check"
  }, {
    "name" : "violateExecutionOnNonTightHtml",
    "description" : "Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at Tight-HTML Rules."
  } ]
}, {
  "patternId" : "OneStatementPerLine",
  "title" : "OneStatementPerLine",
  "parameters" : [ {
    "name" : "treatTryResourcesAsStatement",
    "description" : "Enable resources processing."
  } ]
}, {
  "patternId" : "OneTopLevelClass",
  "title" : "OneTopLevelClass",
  "parameters" : [ ]
}, {
  "patternId" : "OperatorWrap",
  "title" : "OperatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "Specify policy on how to wrap lines."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "OrderedProperties",
  "title" : "OrderedProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "Specify the file extensions of the files to process."
  } ]
}, {
  "patternId" : "OuterTypeFilename",
  "title" : "OuterTypeFilename",
  "parameters" : [ ]
}, {
  "patternId" : "OuterTypeNumber",
  "title" : "OuterTypeNumber",
  "parameters" : [ {
    "name" : "max",
    "description" : "Specify the maximum number of outer types allowed."
  } ]
}, {
  "patternId" : "OverloadMethodsDeclarationOrder",
  "title" : "OverloadMethodsDeclarationOrder",
  "parameters" : [ ]
}, {
  "patternId" : "PackageAnnotation",
  "title" : "PackageAnnotation",
  "parameters" : [ ]
}, {
  "patternId" : "PackageDeclaration",
  "title" : "PackageDeclaration",
  "parameters" : [ {
    "name" : "matchDirectoryStructure",
    "description" : "Control whether to check for directory and package name match."
  } ]
}, {
  "patternId" : "PackageName",
  "title" : "PackageName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Control the pattern to match valid identifiers."
  } ]
}, {
  "patternId" : "ParameterAssignment",
  "title" : "ParameterAssignment",
  "parameters" : [ ]
}, {
  "patternId" : "ParameterName",
  "title" : "ParameterName",
  "parameters" : [ {
    "name" : "accessModifiers",
    "description" : "Access modifiers of methods where parameters are checked."
  }, {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  }, {
    "name" : "ignoreOverridden",
    "description" : "Allows to skip methods with Override annotation from validation."
  } ]
}, {
  "patternId" : "ParameterNumber",
  "title" : "ParameterNumber",
  "parameters" : [ {
    "name" : "ignoreAnnotatedBy",
    "description" : "Ignore methods and constructors annotated with the specified annotation(s)."
  }, {
    "name" : "ignoreOverriddenMethods",
    "description" : "Ignore number of parameters for methods with @Override annotation."
  }, {
    "name" : "max",
    "description" : "Specify the maximum number of parameters allowed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "ParenPad",
  "title" : "ParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "Specify policy on how to pad parentheses."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "PatternVariableName",
  "title" : "PatternVariableName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  } ]
}, {
  "patternId" : "RecordComponentName",
  "title" : "RecordComponentName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  } ]
}, {
  "patternId" : "RecordComponentNumber",
  "title" : "RecordComponentNumber",
  "parameters" : [ {
    "name" : "accessModifiers",
    "description" : "Access modifiers of record definitions where the number of record components should be checked."
  }, {
    "name" : "max",
    "description" : "Specify the maximum number of components allowed in the header of a record definition."
  } ]
}, {
  "patternId" : "RecordTypeParameterName",
  "title" : "RecordTypeParameterName",
  "parameters" : [ {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  } ]
}, {
  "patternId" : "RedundantImport",
  "title" : "RedundantImport",
  "parameters" : [ ]
}, {
  "patternId" : "RedundantModifier",
  "title" : "RedundantModifier",
  "parameters" : [ {
    "name" : "jdkVersion",
    "description" : "jdkVersion"
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "Regexp",
  "title" : "Regexp",
  "parameters" : [ {
    "name" : "duplicateLimit",
    "description" : "Control whether to check for duplicates of a required pattern, any negative value means no checking for duplicates, any positive value is used as the maximum number of allowed duplicates, if the limit is exceeded violations will be logged."
  }, {
    "name" : "errorLimit",
    "description" : "Specify the maximum number of violations before the check will abort."
  }, {
    "name" : "format",
    "description" : "Specify the pattern to match against."
  }, {
    "name" : "ignoreComments",
    "description" : "Control whether to ignore matches found within comments."
  }, {
    "name" : "illegalPattern",
    "description" : "Control whether the pattern is required or illegal."
  }, {
    "name" : "message",
    "description" : "Specify message which is used to notify about violations, if empty then the default (hard-coded) message is used."
  } ]
}, {
  "patternId" : "RegexpHeader",
  "title" : "RegexpHeader",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "Specify the file extensions of the files to process."
  }, {
    "name" : "header",
    "description" : "header"
  }, {
    "name" : "headerFile",
    "description" : "Specify the name of the file containing the required header."
  }, {
    "name" : "multiLines",
    "description" : "Specify the line numbers to repeat (zero or more times)."
  } ]
}, {
  "patternId" : "RegexpMultiline",
  "title" : "RegexpMultiline",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "Specify the file extensions of the files to process."
  }, {
    "name" : "format",
    "description" : "Specify the format of the regular expression to match."
  }, {
    "name" : "ignoreCase",
    "description" : "Control whether to ignore case when searching."
  }, {
    "name" : "matchAcrossLines",
    "description" : "Control whether to match expressions across multiple lines."
  }, {
    "name" : "maximum",
    "description" : "Specify the maximum number of matches required in each file."
  }, {
    "name" : "message",
    "description" : "Specify the message which is used to notify about violations, if empty then default (hard-coded) message is used."
  }, {
    "name" : "minimum",
    "description" : "Specify the minimum number of matches required in each file."
  } ]
}, {
  "patternId" : "RegexpOnFilename",
  "title" : "RegexpOnFilename",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "Specify the file extensions of the files to process."
  }, {
    "name" : "fileNamePattern",
    "description" : "Specify the regular expression to match the file name against."
  }, {
    "name" : "folderPattern",
    "description" : "Specify the regular expression to match the folder path against."
  }, {
    "name" : "ignoreFileNameExtensions",
    "description" : "Control whether to ignore the file extension for the file name match."
  }, {
    "name" : "match",
    "description" : "Control whether to look for a match or mismatch on the file name, if the fileNamePattern is supplied, otherwise it is applied on the folderPattern."
  } ]
}, {
  "patternId" : "RegexpSingleline",
  "title" : "RegexpSingleline",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "Specify the file extensions of the files to process."
  }, {
    "name" : "format",
    "description" : "Specify the format of the regular expression to match."
  }, {
    "name" : "ignoreCase",
    "description" : "Control whether to ignore case when searching."
  }, {
    "name" : "maximum",
    "description" : "Specify the maximum number of matches required in each file."
  }, {
    "name" : "message",
    "description" : "Specify the message which is used to notify about violations, if empty then default (hard-coded) message is used."
  }, {
    "name" : "minimum",
    "description" : "Specify the minimum number of matches required in each file."
  } ]
}, {
  "patternId" : "RegexpSinglelineJava",
  "title" : "RegexpSinglelineJava",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specify the format of the regular expression to match."
  }, {
    "name" : "ignoreCase",
    "description" : "Control whether to ignore case when searching."
  }, {
    "name" : "ignoreComments",
    "description" : "Control whether to ignore text in comments when searching."
  }, {
    "name" : "maximum",
    "description" : "Specify the maximum number of matches required in each file."
  }, {
    "name" : "message",
    "description" : "Specify the message which is used to notify about violations, if empty then default (hard-coded) message is used."
  }, {
    "name" : "minimum",
    "description" : "Specify the minimum number of matches required in each file."
  } ]
}, {
  "patternId" : "RequireEmptyLineBeforeBlockTagGroup",
  "title" : "RequireEmptyLineBeforeBlockTagGroup",
  "parameters" : [ {
    "name" : "violateExecutionOnNonTightHtml",
    "description" : "Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at Tight-HTML Rules."
  } ]
}, {
  "patternId" : "RequireThis",
  "title" : "RequireThis",
  "parameters" : [ {
    "name" : "checkFields",
    "description" : "Control whether to check references to fields."
  }, {
    "name" : "checkMethods",
    "description" : "Control whether to check references to methods."
  }, {
    "name" : "validateOnlyOverlapping",
    "description" : "Control whether to check only overlapping by variables or arguments."
  } ]
}, {
  "patternId" : "ReturnCount",
  "title" : "ReturnCount",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specify method names to ignore."
  }, {
    "name" : "max",
    "description" : "Specify maximum allowed number of return statements in non-void methods/lambdas."
  }, {
    "name" : "maxForVoid",
    "description" : "Specify maximum allowed number of return statements in void methods/constructors/lambdas."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "RightCurly",
  "title" : "RightCurly",
  "parameters" : [ {
    "name" : "option",
    "description" : "Specify the policy on placement of a right curly brace ('}')."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SealedShouldHavePermitsList",
  "title" : "SealedShouldHavePermitsList",
  "parameters" : [ ]
}, {
  "patternId" : "SeparatorWrap",
  "title" : "SeparatorWrap",
  "parameters" : [ {
    "name" : "option",
    "description" : "Specify policy on how to wrap lines."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SimplifyBooleanExpression",
  "title" : "SimplifyBooleanExpression",
  "parameters" : [ ]
}, {
  "patternId" : "SimplifyBooleanReturn",
  "title" : "SimplifyBooleanReturn",
  "parameters" : [ ]
}, {
  "patternId" : "SingleLineJavadoc",
  "title" : "SingleLineJavadoc",
  "parameters" : [ {
    "name" : "ignoreInlineTags",
    "description" : "Control whether inline tags must be ignored."
  }, {
    "name" : "ignoredTags",
    "description" : "Specify block tags which are ignored by the check."
  }, {
    "name" : "violateExecutionOnNonTightHtml",
    "description" : "Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at Tight-HTML Rules."
  } ]
}, {
  "patternId" : "SingleSpaceSeparator",
  "title" : "SingleSpaceSeparator",
  "parameters" : [ {
    "name" : "validateComments",
    "description" : "Control whether to validate whitespaces surrounding comments."
  } ]
}, {
  "patternId" : "StaticVariableName",
  "title" : "StaticVariableName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "Control if check should apply to package-private members."
  }, {
    "name" : "applyToPrivate",
    "description" : "Control if check should apply to private members."
  }, {
    "name" : "applyToProtected",
    "description" : "Control if check should apply to protected members."
  }, {
    "name" : "applyToPublic",
    "description" : "Control if check should apply to public members."
  }, {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  } ]
}, {
  "patternId" : "StringLiteralEquality",
  "title" : "StringLiteralEquality",
  "parameters" : [ ]
}, {
  "patternId" : "SummaryJavadoc",
  "title" : "SummaryJavadoc",
  "parameters" : [ {
    "name" : "forbiddenSummaryFragments",
    "description" : "Specify the regexp for forbidden summary fragments."
  }, {
    "name" : "period",
    "description" : "period"
  }, {
    "name" : "violateExecutionOnNonTightHtml",
    "description" : "Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at Tight-HTML Rules."
  } ]
}, {
  "patternId" : "SuperClone",
  "title" : "SuperClone",
  "parameters" : [ ]
}, {
  "patternId" : "SuperFinalize",
  "title" : "SuperFinalize",
  "parameters" : [ ]
}, {
  "patternId" : "SuppressWarnings",
  "title" : "SuppressWarnings",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specify the RegExp to match against warnings. Any warning being suppressed matching this pattern will be flagged."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "SuppressWarningsHolder",
  "title" : "SuppressWarningsHolder",
  "parameters" : [ {
    "name" : "aliasList",
    "description" : "Specify aliases for check names that can be used in code within SuppressWarnings in a format of comma separated attribute=value entries. The attribute is the fully qualified name of the Check and value is its alias."
  } ]
}, {
  "patternId" : "ThrowsCount",
  "title" : "ThrowsCount",
  "parameters" : [ {
    "name" : "ignorePrivateMethods",
    "description" : "Allow private methods to be ignored."
  }, {
    "name" : "max",
    "description" : "Specify maximum allowed number of throws statements."
  } ]
}, {
  "patternId" : "TodoComment",
  "title" : "TodoComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specify pattern to match comments against."
  } ]
}, {
  "patternId" : "TrailingComment",
  "title" : "TrailingComment",
  "parameters" : [ {
    "name" : "format",
    "description" : "Specify pattern for strings allowed before the comment."
  }, {
    "name" : "legalComment",
    "description" : "Define pattern for text allowed in trailing comments. This pattern will not be applied to multiline comments."
  } ]
}, {
  "patternId" : "Translation",
  "title" : "Translation",
  "parameters" : [ {
    "name" : "baseName",
    "description" : "Specify Base name of resource bundles which contain message resources. It helps the check to distinguish config and localization resources."
  }, {
    "name" : "fileExtensions",
    "description" : "Specify the file extensions of the files to process."
  }, {
    "name" : "requiredTranslations",
    "description" : "Specify language codes of required translations which must exist in project."
  } ]
}, {
  "patternId" : "TypeName",
  "title" : "TypeName",
  "parameters" : [ {
    "name" : "applyToPackage",
    "description" : "Control if check should apply to package-private members."
  }, {
    "name" : "applyToPrivate",
    "description" : "Control if check should apply to private members."
  }, {
    "name" : "applyToProtected",
    "description" : "Control if check should apply to protected members."
  }, {
    "name" : "applyToPublic",
    "description" : "Control if check should apply to public members."
  }, {
    "name" : "format",
    "description" : "Sets the pattern to match valid identifiers."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "TypecastParenPad",
  "title" : "TypecastParenPad",
  "parameters" : [ {
    "name" : "option",
    "description" : "Specify policy on how to pad parentheses."
  } ]
}, {
  "patternId" : "UncommentedMain",
  "title" : "UncommentedMain",
  "parameters" : [ {
    "name" : "excludedClasses",
    "description" : "Specify pattern for qualified names of classes which are allowed to have a main method."
  } ]
}, {
  "patternId" : "UniqueProperties",
  "title" : "UniqueProperties",
  "parameters" : [ {
    "name" : "fileExtensions",
    "description" : "Specify the file extensions of the files to process."
  } ]
}, {
  "patternId" : "UnnecessaryParentheses",
  "title" : "UnnecessaryParentheses",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "UnnecessarySemicolonAfterOuterTypeDeclaration",
  "title" : "UnnecessarySemicolonAfterOuterTypeDeclaration",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "UnnecessarySemicolonAfterTypeMemberDeclaration",
  "title" : "UnnecessarySemicolonAfterTypeMemberDeclaration",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "UnnecessarySemicolonInEnumeration",
  "title" : "UnnecessarySemicolonInEnumeration",
  "parameters" : [ ]
}, {
  "patternId" : "UnnecessarySemicolonInTryWithResources",
  "title" : "UnnecessarySemicolonInTryWithResources",
  "parameters" : [ {
    "name" : "allowWhenNoBraceAfterSemicolon",
    "description" : "Allow unnecessary semicolon if closing parenthesis is not on the same line."
  } ]
}, {
  "patternId" : "UnusedCatchParameterShouldBeUnnamed",
  "title" : "UnusedCatchParameterShouldBeUnnamed",
  "parameters" : [ ]
}, {
  "patternId" : "UnusedImports",
  "title" : "UnusedImports",
  "parameters" : [ {
    "name" : "processJavadoc",
    "description" : "Control whether to process Javadoc comments."
  } ]
}, {
  "patternId" : "UnusedLambdaParameterShouldBeUnnamed",
  "title" : "UnusedLambdaParameterShouldBeUnnamed",
  "parameters" : [ ]
}, {
  "patternId" : "UnusedLocalVariable",
  "title" : "UnusedLocalVariable",
  "parameters" : [ {
    "name" : "allowUnnamedVariables",
    "description" : "Allow variables named with a single underscore (known as unnamed variables in Java 21+)."
  } ]
}, {
  "patternId" : "UpperEll",
  "title" : "UpperEll",
  "parameters" : [ ]
}, {
  "patternId" : "VariableDeclarationUsageDistance",
  "title" : "VariableDeclarationUsageDistance",
  "parameters" : [ {
    "name" : "allowedDistance",
    "description" : "Specify distance between declaration of variable and its first usage. Values should be greater than 0."
  }, {
    "name" : "ignoreFinal",
    "description" : "Allow to ignore variables with a 'final' modifier."
  }, {
    "name" : "ignoreVariablePattern",
    "description" : "Define RegExp to ignore distance calculation for variables listed in this pattern."
  }, {
    "name" : "validateBetweenScopes",
    "description" : "Allow to calculate the distance between declaration of variable and its first usage in the different scopes."
  } ]
}, {
  "patternId" : "VisibilityModifier",
  "title" : "VisibilityModifier",
  "parameters" : [ {
    "name" : "allowPublicFinalFields",
    "description" : "Allow final fields to be declared as public."
  }, {
    "name" : "allowPublicImmutableFields",
    "description" : "Allow immutable fields to be declared as public if defined in final class."
  }, {
    "name" : "ignoreAnnotationCanonicalNames",
    "description" : "Specify annotations canonical names which ignore variables in consideration."
  }, {
    "name" : "immutableClassCanonicalNames",
    "description" : "Specify immutable classes canonical names."
  }, {
    "name" : "packageAllowed",
    "description" : "Control whether package visible members are allowed."
  }, {
    "name" : "protectedAllowed",
    "description" : "Control whether protected members are allowed."
  }, {
    "name" : "publicMemberPattern",
    "description" : "Specify pattern for public members that should be ignored."
  } ]
}, {
  "patternId" : "WhenShouldBeUsed",
  "title" : "WhenShouldBeUsed",
  "parameters" : [ ]
}, {
  "patternId" : "WhitespaceAfter",
  "title" : "WhitespaceAfter",
  "parameters" : [ {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WhitespaceAround",
  "title" : "WhitespaceAround",
  "parameters" : [ {
    "name" : "allowEmptyCatches",
    "description" : "Allow empty catch bodies."
  }, {
    "name" : "allowEmptyConstructors",
    "description" : "Allow empty constructor bodies."
  }, {
    "name" : "allowEmptyLambdas",
    "description" : "Allow empty lambda bodies."
  }, {
    "name" : "allowEmptyLoops",
    "description" : "Allow empty loop bodies."
  }, {
    "name" : "allowEmptyMethods",
    "description" : "Allow empty method bodies."
  }, {
    "name" : "allowEmptySwitchBlockStatements",
    "description" : "Allow empty switch blocks and block statements."
  }, {
    "name" : "allowEmptyTypes",
    "description" : "Allow empty class, interface and enum bodies."
  }, {
    "name" : "ignoreEnhancedForColon",
    "description" : "Ignore whitespace around colon in enhanced for loop."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
}, {
  "patternId" : "WriteTag",
  "title" : "WriteTag",
  "parameters" : [ {
    "name" : "tag",
    "description" : "Specify the name of tag."
  }, {
    "name" : "tagFormat",
    "description" : "Specify the regexp to match tag content."
  }, {
    "name" : "tagSeverity",
    "description" : "Specify the severity level when tag is found and printed."
  }, {
    "name" : "tokens",
    "description" : "tokens to check"
  } ]
} ]
